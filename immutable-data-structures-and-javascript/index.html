<!DOCTYPE html>
<html>
  <head>
    <title>Immutable Data Structures and Javascript | Lucas Reis' Blog</title>
    <link rel="stylesheet" href="../styles/reset.css" type="text/css">
    <link rel="stylesheet" href="../styles/style.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Lato:300,900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">
  </head>
  <body>
    <div id="container">
      <header>
        <ul>
          <li class="active"><a href="../contents/">Blog</a></li>
          <li><a href="../">About</a></li>
        </ul>
      </header>
      <div id="main-text">
        <h1>Immutable Data Structures and Javascript</h1>
        <div class="lead">Using Mori to bring simplicity to state handling</div>
        <p>One of the most difficult - perhaps <em>the</em> most difficult - issue in a complex front end application is state handling. I&#39;ve written before about storing <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular/">all application state</a> in a <a href="http://lucasmreis.github.io/blog/a-more-functional-approach-to-angular-with-baobab/">single, centralized object</a>, and now I&#39;ll do it using <em>immutable data structures</em>.</p>
<p>I found that working with immutable data structures actually made the implementation <em>much simpler</em>! How can a limitation make something more powerful, one may ask? Follow me and let me explain.</p>
<h2 id="why-did-i-try-this-immutable-thing">Why did I try this immutable thing</h2>
<p>First of all, because I&#39;ve been watching a lot of Rich Hickey videos lately, and everything this guy says just make sense. He says that an immutable collection is not only an &quot;array that cannot be modified&quot;, but it is an <em>array that can be treated as a value</em>.</p>
<p>When we have two Numbers or two Strings, and we want to know if they are equal, we simply ask &quot;are they equal?&quot; by using the <code>===</code> operator. That&#39;s it - <code>2</code> always equals <code>2</code>, and if <code>a = 2</code> and <code>b = 2</code> we can say for sure that <code>a === b</code>. The same would be true for other values like <code>&#39;this string&#39; === &#39;this string&#39;</code>.</p>
<p>But, if we have two arrays or objects, <code>===</code> does not work the same way. It works by comparing references, so <code>[1, 2, 3] === [1, 2, 3]</code> is false, because they are actually <em>two different collections that happen to have the same values</em>.</p>
<p>When working with immutable collections and objects, they are compared just like values. If they have the same elements, they are the same collection. Simple, isn&#39;t it? :)</p>
<p>This is possible due to smart algorithms and data structure implementation made by libraries like <a href="http://swannodette.github.io/mori/">Mori</a> and <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>. I will not go into detail here, but here&#39;s what we need to know regarding these data structures:</p>
<pre><code class="hljs js">import Mori from <span class="hljs-string">'mori'</span>;

<span class="hljs-comment">// a vector is an example of</span>
<span class="hljs-comment">// immutable data structure</span>
<span class="hljs-keyword">const</span> a = mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">// conj appends a value to the</span>
<span class="hljs-comment">// end of a vector, and returns</span>
<span class="hljs-comment">// a new vector</span>
<span class="hljs-keyword">const</span> b = mori.conj(a, <span class="hljs-number">4</span>);

mori.equals(b, mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
<span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// cool feature: the original vector is preserved</span>
<span class="hljs-comment">//   (that's why they are also called</span>
<span class="hljs-comment">//   persistent data structures)</span>
mori.equals(a, mori.vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
<span class="hljs-comment">// =&gt; true</span></code></pre>

<p><strong>Question 1.</strong> Are the objects cloned every time I apply a transformation? <strong>No.</strong> And that&#39;s a key part of the reason the performance is almost the same as the mutable counterparts. These libraries are implemented so that a transformed object <em>share as much memory as possible</em> with the original object. (<a href="">more details here</a>)</p>
<p><strong>Question 2.</strong> That means that storing transformed versions of objects use little memory? <strong>Yes!</strong> If we have an one million elements conventional array that occupies 1GB of memory, clone it, append an element, and save both versions, we&#39;ll use 2GB of memory. If we use an immutable vector and <code>conj</code>, storing both versions will not occupy much more than storing only one vectors.</p>
<p>Pause a little bit to think about this last property of immutable objects, and think of how much awesomeness this &quot;limitation&quot; can bring to your code. ;)</p>
<h2 id="back-to-application-state">Back to application state</h2>
<p>The application will only consist of two lists, Foos and Bars. The user can add a new Foo or a new Bar by the app inputs. Foos and Bars are unique.</p>
<p>Let&#39;s do it step by step:</p>
<ul>
<li>The application state will be represented by a vector of hashmaps. The last hasmap will be the current state:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">const</span> initialValue = hashMap(
  <span class="hljs-string">'foos'</span>, set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-string">'bars'</span>, set([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]));

<span class="hljs-comment">// sets are unordered lists that have</span>
<span class="hljs-comment">// unique elements</span>

<span class="hljs-keyword">let</span> history = vector(initialValue);

<span class="hljs-comment">// get current state</span>
export <span class="hljs-keyword">const</span> currentState = () =&gt; peek(history);</code></pre>

<ul>
<li>To react to changes in the state, we register listeners. It consists of two functions: <code>listenTo</code>, that specifies a part/transformation of the state which will be listened to, and a <code>callback</code> to run if the state changes:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
<span class="hljs-keyword">let</span> listeners = vector();

export <span class="hljs-keyword">const</span> listen = (listenTo, callback) =&gt; {
  listeners = conj(listeners, hashMap(
    <span class="hljs-string">'listenTo'</span>, listenTo,
    <span class="hljs-string">'callback'</span>, callback
  ));
};</code></pre>

<p>Example of a <code>listen</code> call:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> prop = key =&gt; o =&gt; Mori.get(o, key);
listen(prop(<span class="hljs-string">'bars'</span>), renderSomething);</code></pre>

<p>That means that everytime the property <code>bars</code> change, the function <code>renderSomething</code> will be run with <code>bars</code> as argument.</p>
<ul>
<li>To change state, one calls the update function. It changes it and call all listeners if their new <code>listenTo</code> result is different from the previous state:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>

<span class="hljs-comment">// callListener is called by the update</span>
<span class="hljs-comment">// function for each listener registered, with</span>
<span class="hljs-comment">// the previous and the new state value:</span>
<span class="hljs-keyword">const</span> callListener =
  (previousState, newState) =&gt; listener =&gt; {

    <span class="hljs-keyword">const</span> listenTo =
    get(listener, <span class="hljs-string">'listenTo'</span>);

  <span class="hljs-keyword">const</span> previousListenTo =
    listenTo(previousState);

  <span class="hljs-keyword">const</span> newListenTo =
    listenTo(newState);

    <span class="hljs-comment">// if state does not change for</span>
    <span class="hljs-comment">// listener, nothing happens.</span>
    <span class="hljs-comment">// Remember 'equals' is super cheap! :)</span>
  <span class="hljs-keyword">if</span> (!equals(
    previousListenTo, newListenTo)) {
        get(listener, <span class="hljs-string">'callback'</span>)(newListenTo);
  }
  };

export <span class="hljs-keyword">const</span> update = fn =&gt; {
  <span class="hljs-keyword">const</span> previousState = peek(history);

  <span class="hljs-comment">// calculate new state</span>
  <span class="hljs-keyword">const</span> newState = fn(previousState);

  <span class="hljs-keyword">if</span> (!equals(previousState, newState)) {
    <span class="hljs-comment">// add new state to history.</span>
    <span class="hljs-comment">// Remember our data structures</span>
    <span class="hljs-comment">// are persistent, and share</span>
    <span class="hljs-comment">// memory space! :)</span>
    history = conj(history, newState);

    <span class="hljs-comment">// fire listener callbacks</span>
    each(listeners, callListener(previousState, newState));
  }
};</code></pre>

<ul>
<li>Good bonus: undo!</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// appState.js</span>
export <span class="hljs-keyword">const</span> undo = () =&gt; {
  <span class="hljs-keyword">if</span> (count(history) &gt; <span class="hljs-number">1</span>) {

    <span class="hljs-keyword">const</span> previousState =
      peek(history);

    history =
      subvec(history, <span class="hljs-number">0</span>, count(history) - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">const</span> newState =
      peek(history);

    each(listeners,
      callListener(previousState, newState));
  }
}</code></pre>

<ul>
<li>One can use</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// render.js</span>
export <span class="hljs-keyword">let</span> renderList = elem =&gt; seq =&gt;
  elem.innerHTML =
    reduce(makeLi, <span class="hljs-string">'&lt;ul&gt;'</span>, seq) + <span class="hljs-string">'&lt;/ul&gt;'</span>;

<span class="hljs-comment">// index.js</span>

<span class="hljs-comment">// starts by rendering initial state:</span>
<span class="hljs-keyword">const</span> initialState =
  currentState();

renderList
  (foosElement)
  (get(initialState, <span class="hljs-string">'foos'</span>));

<span class="hljs-comment">// renders again on state change:</span>
listen(prop(<span class="hljs-string">'foos'</span>),
  renderList(foosElement));</code></pre>

<ul>
<li>User interactions will call the <code>update</code> function to change state. The argument passed is a function that will transform the current state. Let&#39;s call those transformations commands:</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// command.js</span>
<span class="hljs-keyword">const</span> conjItem = item =&gt; coll =&gt;
  conj(coll, item);

export <span class="hljs-keyword">const</span> addFoo = foo =&gt; state =&gt;
  updateIn(state, [<span class="hljs-string">'foos'</span>], conjItem(foo));

<span class="hljs-comment">// index.js</span>

<span class="hljs-comment">// input</span>
<span class="hljs-keyword">let</span> newFooElement =
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'new-foo'</span>);

<span class="hljs-comment">// button</span>
<span class="hljs-keyword">let</span> addFooElement =
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'add-foo'</span>);

addFooElement.onclick = () =&gt;
  update(addFoo(newFooElement.value));</code></pre>

<p>And that&#39;s it!</p>
<p>The architecture is really simple, let&#39;s recap it:</p>
<ul>
<li>The application state is represented by an immutable object.</li>
<li>The views are rendered according to the state object.</li>
<li>Listeners with callbacks are registered. Changes in state cause callbacks to be called.</li>
<li>State is changed by calling the update function.</li>
<li>User interactions or any other event can call the update function.</li>
</ul>
<h2 id="and-what-did-we-gain-by-using-immutable-data-structures-">And what did we gain by using immutable data structures?</h2>
<p>My first impression was: it was simple. After getting used to the Mori functions, it is very straightforward to manipulate the data structures. And the fact that Mori handles memory and performance very well makes the code very direct too.</p>
<p>Immutable persistent data structures make comparison very cheap, and it proved to be very important to the update function. Memory sharing is also an amazing feature that practically gave &quot;undo&quot; for free.</p>
<p>So, in the end it made easy, explicit and performant to implement application state as series of values.</p>
<h2 id="next-steps">Next steps</h2>
<p>I chose Mori because it&#39;s an interface to clojurescript native data structures. <a href="http://clojure.org/">Clojure</a> is an amazing language, and I&#39;m starting to study and experiment with it now.</p>
<p>Staying in javascript, it would also be interesting to get a look at <a href="https://facebook.github.io/immutable-js/">immutable.js</a>. It&#39;s maintained by facebook, and seems to play very well with React.</p>

        <div class="signature">July 3, 2015.</div>
      </div>

      <!-- DISQUS -->
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES * * */
          var disqus_shortname = 'lucasmreis';
          var disqus_identifier = 'immutable-data-structures-and-javascript';
          var disqus_title = 'Immutable Data Structures and Javascript';

          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

      <footer>
        by Lucas Reis | <a href="https://github.com/lucasmreis">GitHub</a> | <a href="https://www.linkedin.com/profile/view?id=133974663">LinkedIn</a>
      </footer>
    </div>

    <!-- GOOGLE ANALYTICS -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-60280937-1', 'auto');
      ga('send', 'pageview');
    </script>

  </body>
</html>